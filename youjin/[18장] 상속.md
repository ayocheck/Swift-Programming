### 상속(Inheritance)
- 클래스가 메서드나 프로퍼티 등을 다른 클래스로부터 **물려받을 수 있는** 것
    - 클래스는 그 어떤 클래스의 **자식클래스(Subclass/Child-class)**라고 표현
    - 자식클래스에게 자신의 특성을 물려준 클래스를 **부모클래스(Superclass/Parents-class)**라고 표현

### 상속의 특징
- Swift의 클래스는 부모클래스로부터 물려받은 메서드를 호출할 수 있고 프로퍼티에 접근할 수 있음
- 서브스크립트도 사용할 수 있음
- 부모클래스의 요소를 자식클래스에서 재정의하여 자신만의 기능으로 변경하여 사용할 수 있음
- 여러 서브스크립트를 한 타입에 구현하는 것을 서브스크립트 중복 정의(Subscript Overloading)라고 함

### 기본 구조
- 클래스 이름 뒤에 콜론을 붙이고 다른 클래스 이름을 써주면 뒤에 오는 클래스의 기능을 앞의 클래스가 상속받을 것임을 뜻함
```swift
class 클래스 이름: 부모클래스 이름 {
    프로퍼티와 메서드들
}
```

### 클래스 상속

- 상속은 **기반클래스를 다른 클래스에서 물려받는 것**을 말함
- 부모클래스의 메서드, 프로퍼티 등을 재정의하거나 기반클래스의 기능이나 프로퍼티를 물려받고 자신의 기능을 추가할 수 있음
- 클래스 이름 뒤에 콜론을 붙이고 다른 클래스 이름을 써주면 뒤에 오는 클래스의 기능을 앞의 클래스가 상속받을 것임을 뜻함
- 다른 클래스를 상속받으면 똑같은 기능을 구현하기 위해 코드를 다시 작성할 필요가 없으므로 코드를 재사용하기 용이함
- 또한 기능을 확장할 때 기존 클래스를 변경하지 않고도 새로운 추가 기능을 구현한 클래스를 정의할 수 있음

---

### 재정의(Override)
- 자식클래스는 부모클래스로부터 물려받은 특성(인스턴스 메서드, 타입 메서드, 인스턴스 프로퍼티, 타입 프로퍼티, 서브스크립트 등)을 그대로 사용하지 않고 자신만의 기능으로 변경하여 사용할 수 있음
- 상속받은 특성을 재정의하려면 새로운 정의 앞에 `override`라는 키워드를 사용함
- `override` 키워드는 스위프트 컴파일러가 조상클래스(부모를 포함한 그 상위 부모클래스)에 해당 특성이 있는지 확인한 후 재정의하게 됨
    - ** 만약 조상클래스에 재정의할 해당 특성이 없다면 `override` 키워드를 사용하면 컴파일 오류가 발생합니다. **

### 잘못된 override 키워드 사용으로 인한 오류 발생 예시

```swift
override func someMethod() { } 
// ⚠️ Method does not override any method from its superclass
```

### super 키워드 사용법
- 만약 자식클래스에서 부모클래스의 특성을 재정의했을 때 부모클래스의 특성을 자식클래스에서 사용하고 싶다면 `super` 프로퍼티를 사용

```
재정의한 someMethod()의 부모 버전을 호출하고 싶다면 → `super.someMethod()`
재정의한 someProperty의 부모 버전에 접근하고 싶다면 → `super.someProperty`
재정의한 서브스크립트에서 부모 버전의 서브스크립트로 접근하고 싶다면 → `super[index]`
```

### 메서드 재정의
- 부모클래스로부터 상속받은 인스턴스 메서드나 타입 메서드를 자식클래스에서 용도에 맞도록 재정의할 수 있음

### 프로퍼티 재정의
- 메서드와 마찬가지로 부모클래스로부터 상속받은 인스턴스 프로퍼티나 타입 프로퍼티를 자식클래스에서 용도에 맞게 재정의할 수 있음

### 프로퍼티 재정의 규칙
- 프로퍼티를 재정의할 때는 저장 프로퍼티로 재정의할 수는 없음 
    - 프로퍼티를 재정의한다는 것은 프로퍼티 자체가 아니라 프로퍼티의 접근자, 설정자, 프로퍼티 감시자 등을 재정의하는 것을 의미하기 때문
- 조상클래스에서 저장 프로퍼티로 정의한 프로퍼티는 물론이고 연산 프로퍼티로 정의한 프로퍼티도 접근자와 설정자를 재정의할 수 있음
    - 프로퍼티를 상속받은 자식클래스에서는 조상클래스의 프로퍼티 종류(저장, 연산 등)는 알지 못하고 단지 이름과 타입만을 알기 때문

### 재정의 가능한 프로퍼티 조합
- **조상클래스에서 읽기 전용 프로퍼티였다면 자식클래스에서 읽고 쓰기가 가능한 프로퍼티로 재정의해줄 수도 있움** 
    - 그러나 읽기 쓰기 모두 가능했던 프로퍼티를 읽기 전용으로 재정의해줄 수 없음
- 읽기 쓰기가 모두 가능한 프로퍼티를 재정의할 때 설정자만 따로 재정의할 수는 없음
    - 즉, 접근자와 설정자를 모두 재정의해야 함
    - 만약 접근에 따라 기능 변경이 필요 없다면 `super.someProperty`와 같은 식으로 부모클래스의 접근자를 사용하여 값을 반환

### 프로퍼티 감시자 재정의
- 프로퍼티 감시자도 프로퍼티의 접근자와 설정자처럼 재정의 가능
    - 조상클래스에 정의한 프로퍼티가 연산 프로퍼티인지 저장 프로퍼티인지 상관없음
    - 다만 상수 저장 프로퍼티나 읽기 전용 연산 프로퍼티는 프로퍼티 감시자를 재정의할 수 없음
        - 상수나 읽기 전용 프로퍼티는 값을 설정할 수 없으므로 willSet이나 didSet 메서드를 사용한 프로퍼티 감시자를 원적으로 사용할 수 없기 때문
        - 프로퍼티 감시자를 재정의하더라도 조상클래스에 정의한 프로퍼티 감시자도 동작
    - 프로퍼티의 접근자와 프로퍼티 감시자는 동시에 재정의할 수 없음
        - 둘 다 동작하길 원한다면 재정의하는 접근자에 프로퍼티 감시자의 역할을 구현


### 서브스크립트 재정의
- 메서드와 마찬가지로 재정의 가능
- 서브스크립트도 매개변수와 반환 타입이 다르면 다른 서브스크립트로 취급하므로 자식클래스에서 재정의하려는 서브스크립트라면 부모클래스 서브스크립트의 매개변수와 반환 타입이 같아야 함
- 부모클래스를 상속받는 자식클래스에서 몇몇 특성을 재정의할 수 없도록 제한하고 싶다면 재정의를 방지하고 싶은 특성 앞에 `final` 키워드를 명시
    - `final var`, `final func`, `final class func`, `final subscript`와 같이 표현
- 재정의를 방지한 특성을 자식클래스에서 재정의하려고 하면 컴파일 오류가 발생
    - 클래스를 상속하거나 재정의할 수 없도록 하고 싶다면 `class` 키워드 앞에 `final` 키워드를 붙여주면 됩

### 지정 이니셜라이저와 편의 이니셜라이저
- 지정 이니셜라이저(Designated Initializer)
    - 클래스의 주요 이니셜라이저
    - 필요에 따라 부모클래스의 이니셜라이저를 호출할 수 있으며 이니셜라이저가 정의된 클래스의 모든 프로퍼티를 초기화해야 하는 임무를 갖고 있음
- 편의 이니셜라이저(Convenience Initializer)
    - 초기화를 좀 더 손쉽게 도와주는 역할 
    - 지정 이니셜라이저를 자신 내부에서 호출
    - 지정 이니셜라이저의 매개변수가 많아 외부에서 일일이 전달인자를 전달하기 어렵거나 특정 목적에 사용하기 위해서 편의 이니셜라이저를 설계할 수 있음

### 이니셜라이저 정의 문법

```swift
// 지정 이니셜라이저
init(매개변수들) {
    초기화 구문
}

// 편의 이니셜라이저
convenience init(매개변수들) {
    초기화 구문
}
```
- 편의 이니셜라이저는 앞에 `convenience` 지정자를 `init` 키워드 앞에 명시

### 클래스의 초기화 위임 규칙
1. **자식클래스의 지정 이니셜라이저는 부모클래스의 지정 이니셜라이저를 반드시 호출해야 합니다.**
2. **편의 이니셜라이저는 자신을 정의한 클래스의 다른 이니셜라이저를 반드시 호출해야 합니다.**
3. **편의 이니셜라이저는 궁극적으로는 지정 이니셜라이저를 반드시 호출해야 합니다.**

### 2단계 초기화
- 스위프트의 클래스 초기화는 2단계를 거침
    - 1단계: 클래스에 정의한 각각의 저장 프로퍼티에 초깃값이 할당
        - 모든 저장 프로퍼티의 초기 상태가 결정되면 2단계로 넘어감
    - 2단계: 저장 프로퍼티들을 사용자 정의할 기회를 얻음
        - 2단계 이후 비로소 새로운 인스턴스를 사용할 준비가 끝납니다.

### 2단계 초기화 과정
- 2단계 초기화는 프로퍼티를 초기화하기 전에 프로퍼티 값에 접근하는 것을 막아 초기화를 안전하게 할 수 있도록 해줌
- 또 다른 이니셜라이저가 프로퍼티의 값을 실수로 변경하는 것을 방지할 수 있음
- 스위프트 컴파일러는 2단계 초기화를 오류 없이 처리하기 위해 다음과 같은 네 가지 안전확인을 실행함

```
1. 자식클래스의 지정 이니셜라이저가 부모클래스의 이니셜라이저를 호출하기 전에 자신의 프로퍼티를 모두 초기화했는지 확인
2. 자식클래스의 지정 이니셜라이저는 상속받은 프로퍼티에 값을 할당하기 전에 반드시 부모클래스의 이니셜라이저를 호출
3. 편의 이니셜라이저는 자신의 클래스에 정의한 프로퍼티를 포함하여 그 어떤 프로퍼티라도 값을 할당하기 전에 다른 이니셜라이저를 호출
4. 초기화 1단계를 마치기 전까지는 이니셜라이저는 인스턴스 메서드를 호출할 수 없음
    - 또 인스턴스 프로퍼티의 값을 읽어들일 수 없음 
    - self 프로퍼티를 자신의 인스턴스를 나타내는 값으로 활용할 수 없음
```

- 클래스의 인스턴스는 초기화 1단계를 마치기 전까지는 아직 유효하지 않음
    - 프로퍼티는 읽기만 가능하며 메서드는 호출할 수 있을 뿐 
    - 클래스의 인스턴스가 초기화 1단계를 마쳤을 때 비로소 유효한 인스턴스가 됨
