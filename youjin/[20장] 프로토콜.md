## 프로토콜이란? (Protocol)
- 특정 역할을 하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 **청사진**을 정의
- 구조체, 클래스, 열거형은 프로토콜을 **채택(Adopted)**해서 특정 기능을 실행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있음
- 어떤 프로토콜의 요구사항을 모두 따르는 타입은 해당 프로토콜을 **준수한다(Conform)**고 표현
- **프로토콜은 정의 및 제시할 뿐, 스스로 기능을 구현하지 않음**

## 프로토콜 채택
- 프로토콜은 구조체, 클래스, 열거형의 모양과 비슷하게 정의 가능함
- `protocol` 키워드 사용
- 구조체, 클래스, 열거형 등에서 프로토콜을 채택하려면 
    - 타입 이름 뒤에 콜론(`:`)을 붙여준 후 채택할 프로토콜 이름을 쉼표(`,`)로 구분하여 명시

## 프로토콜 요구사항
- 프로토콜은 타입이 특정 기능을 실행하기 위해 필요한 기능을 요구함
- 프로토콜이 자신을 채택한 타입에 요구하는 사항
    - 프로퍼티나 메서드와 같은 기능들

### 프로퍼티 요구
- 프로토콜은 자신을 채택한 타입이 어떤 프로퍼티를 구현해야 하는지 요구할 수 있음
- 그렇지만 프로토콜은 그 프로퍼티의 종류(연산 프로퍼티인지, 저장 프로퍼티인지 등)는 따로 신경쓰지 않음
- 프로토콜의 프로퍼티 요구사항은 항상 `var` 키워드를 사용한 변수 프로퍼티로 정의
    - 읽기와 쓰기 모두 가능한 프로퍼티는 프로퍼티의 정의 뒤에 `{ get set }`이라고 명시함
    - 읽기 전용 프로퍼티는 프로퍼티의 정의 뒤에 `{ get }`이라고 명시함
- 타입 프로퍼티를 요구할 때는 `static` 키워드를 사용함

### 메서드 요구
- 프로토콜은 특정 인스턴스 메서드나 타입 메서드를 요구할 수 있음
- 프로토콜의 메서드 요구에서는 매개변수 기본값을 지정할 수 없음
- 프로토콜이 요구할 메서드는 프로토콜 정의에서 작성
    - 다만 메서드의 실제 구현부인 중괄호(`{}`) 부분은 제외하고 메서드의 이름, 매개변수, 반환 타입 등만 작성하며 가변 매개변수도 허용
- 타입 메서드를 요구할 때는 타입 프로퍼티 요구와 마찬가지로 앞에 `static` 키워드를 명시함
    - `static` 키워드를 사용하여 요구한 타입 메서드를 클래스에서 실제 구현할 때는 `static` 키워드나 `class` 키워드 어느 쪽을 사용해도 무방함

### 가변 메서드 요구
- 가끔은 메서드가 인스턴스 내부의 값을 변경할 필요가 있음
- 값 타입(구조체와 열거형)의 인스턴스 메서드에서 자신 내부의 값을 변경하고자 할 때
    - 메서드의 `func` 키워드 앞에 `mutating` 키워드를 적어 메서드에서 인스턴스 내부의 값을 변경한다는 것을 확실히 해줌
- 프로토콜이 어떤 타입이든 간에 인스턴스 내부의 값을 변경해야 하는 메서드를 요구하려면 프로토콜의 메서드 정의 앞에 `mutating` 키워드를 명시해야 함
- 프로토콜에 `mutating` 키워드를 사용한 메서드 요구가 있다고 하더라도 클래스 구현에는 `mutating` 키워드를 써주지 않아도 됨

### 이니셜라이저 요구
- 프로토콜은 프로퍼티, 메서드 등과 마찬가지로 특정한 이니셜라이저를 요구할 수도 있음
- 프로토콜에서 이니셜라이저를 요구하려면 메서드 요구와 마찬가지로 이니셜라이저를 정의하지만 구현은 하지 않음
- 즉, 이니셜라이저의 매개변수를 지정하기만 할 뿐, 중괄호를 포함한 이니셜라이저 구현은 하지 않음
- 클래스 타입에서 프로토콜의 이니셜라이저 요구에 부합하는 이니셜라이저를 구현할 때
    - 이니셜라이저를 구현할 때 `required` 식별자를 붙인 요구 이니셜라이저로 구현해야 함
    - 만약 클래스 자체가 상속받을 수 없는 `final` 클래스라면 `required` 식별자를 붙여줄 필요가 없음
- 만약 특정 클래스에 프로토콜이 요구하는 이니셜라이저가 이미 구현되어 있는 상황에서 그 클래스를 상속받은 클래스가 있다면
    - `required`와 `override` 식별자를 모두 명시하여 프로토콜에서 요구하는 이니셜라이저를 구현해주어야 함

## 프로토콜의 상속과 클래스 전용 프로토콜
- 프로토콜은 하나 이상의 프로토콜을 상속받아 기존 프로토콜의 요구사항보다 더 많은 요구사항을 추가할 수 있음
- 프로토콜 상속 문법은 클래스의 상속 문법과 유사
- 프로토콜의 상속 리스트에 `AnyObject`를 추가해 프로토콜이 클래스 타입에만 채택되도록 제한할 수도 있음

## 프로토콜 조합과 프로토콜 준수 확인
- 하나의 매개변수가 여러 프로토콜을 모두 준수하는 타입이어야 한다면 하나의 매개변수에 여러 프로토콜을 한 번에 **조합(Composition)**해 요구할 수 있음
- 프로토콜을 조합하여 요구할 때는 `SomeProtocol & AnotherProtocol`과 같이 표현함
- 또 하나의 매개변수가 프로토콜을 둘 이상 요구할 수도 있음
    - 마찬가지로 앰퍼샌드(`&`)를 여러 프로토콜 이름 사이에 써주면 됨
- 더불어 특정 클래스의 인스턴스 역할을 할 수 있는지 함께 확인할 수 있음
    - 구조체나 열거형 타입은 조합할 수 없음
    - 조합 중 클래스 타입은 한 타입만 조합할 수 있음

### 프로토콜 준수 확인
- 타입캐스팅에 사용하던 `is`와 `as` 연산자를 통해 대상이 프로토콜을 준수하는지 확인하고 특정 프로토콜로 캐스팅할 수 있음
    - 프로토콜을 준수하는지 확인하거나 다른 프로토콜로 캐스팅하는 방법은 타입캐스팅 방법과 동일
- `is` 연산자를 통해 해당 인스턴스가 특정 프로토콜을 준수하는지 확인할 수 있음
- `as?` 다운캐스팅 연산자를 통해 다른 프로토콜로 다운캐스팅을 시도해볼 수 있음
- `as!` 다운캐스팅 연산자를 통해 다른 프로토콜로 강제 다운캐스팅을 할 수 있음

## 프로토콜의 선택적 요구
- 프로토콜의 요구사항 중 일부를 선택적 요구사항으로 지정할 수 있음
- 선택적 요구사항은 `optional` 식별자를 요구사항의 정의 앞에 붙여주면 됨
    - 만약 메서드나 프로퍼티를 선택적 요구사항으로 요구하게 되면 그 요구사항의 타입은 자동적으로 옵셔널이 됨
    - 선택적 요구사항은 그 프로토콜을 준수하는 타입에 구현되어 있지 않을 수도 있기 때문에 옵셔널 체이닝을 통해 호출할 수 있음

## 실존 타입으로서의 프로토콜
- 프로토콜을 타입으로 갖는 변수 또는 상수에는 해당 프로토콜을 준수하는 타입의 모든 인스턴스를 할당할 수 있음
- 프로토콜이 이렇게 타입으로 활용될 때 이를 **실존 타입(Existential Type)**이라고 부름
    - 프로토콜이 실존 타입으로 활용될 때는 앞에 `any`를 붙여 **구체 타입(Concrete Type)**과 구분해줌
- 구체 타입은 클래스, 구조체, 열거형 등 실체가 있는 타입을 뜻함

### 실존 타입 사용 시 주의사항
- 실존 타입을 구체 타입과 구분하여 `any`를 명시하는 이유는 프로그래머에게 코드의 동작 성능에 대해 경각심을 주기 위해서
- 실존 타입을 사용하면 변수 활용에 유연함을 줄 수 있지만 실행 성능이 떨어질 수 있음
- 실행 성능을 향상하기 위해서는 실존 타입 대신 제네릭(22장)을 활용할 수 있음

## 위임을 위한 프로토콜
- **위임(Delegation)**: 클래스나 구조체가 자신의 책임이나 임무를 다른 타입의 인스턴스에게 위임하는 디자인 패턴
- 책무를 위임하기 위해 정의한 프로토콜을 준수하는 타입은 자신에게 위임될 일정 책무를 할 수 있다는 것을 보장
- 위임은 사용자의 특정 행동에 반응하기 위해 사용되기도 하며, 비동기 처리에도 많이 사용
- **위임 패턴(Delegation Pattern)**은 애플의 프레임워크에서 사용하는 주요한 패턴 중 하나
