## 제네릭 (Generic)
- 제네릭을 이용해 코드를 구현하면 어떤 타입에도 유연하게 대응할 수 있음
- 제네릭으로 구현한 기능과 타입은 재사용하기도 쉽고, 코드의 중복을 줄일 수 있기에 깔끔하고 추상적인 표현이 가능

### 제네릭의 활용 사례
- 스위프트 표준 라이브러리 또한 수많은 제네릭 코드로 구성되어 있음
- 우리는 지금까지 제네릭 기능을 수없이 사용
    - 예: Array, Dictionary, Set 등의 타입은 모두 제네릭 컬렉션
- Int나 String 타입을 요소로 갖는 배열을 만들거나 그 외의 어떤 타입도 배열을 요소로 가질 수 있었던 것은 모두 제네릭 덕분

### 제네릭 사용 방법
- 제네릭이 필요한 타입 또는 메서드의 이름 뒤의 **홀화살괄호 기호(`<>`)** 사이에 제네릭을 위한 타입 매개변수를 써줌

## 타입 매개변수 (Type Parameter)
- 제네릭 함수는 실제 타입 이름(Int, String 등)을 써주는 대신에 **플레이스홀더(Placeholder)**를 사용
- 플레이스홀더(T)는 타입의 종류를 알려주지 않지만 말 그대로 어떤 타입이라는 것은 알려줌
    - T의 실제 타입은 함수가 호출되는 그 순간 결정
- **타입 매개변수**는 플레이스홀더 타입의 이름을 지정하고 명시하는 역할을 하며, 함수의 이름 뒤 홀화살괄호 기호(`<>`) 안쪽에 위치

### 타입 매개변수 명명 규칙
- 타입 매개변수 대부분은 의미있는 이름을 가짐
    - e.g. Dictionary의 Key, Value, Array의 Element
- 특별한 관계의 의미를 이름으로 표현하기 어려울 때는 관용적으로 T, U, V 등의 대문자 한 글자로 표현

## 제네릭 타입
- 제네릭 타입을 구현하면 사용자 정의 타입인 구조체, 클래스, 열거형 등이 어떤 타입과도 연관되어 동작할 수 있음 
    - Array와 Dictionary 타입이 자신의 요소로 모든 타입을 대상으로 동작할 수 있는 것과 유사

### 제네릭 타입 확장
- 만약 익스텐션을 통해 제네릭을 사용하는 타입에 기능을 추가하고자 한다면 익스텐션 정의에 타입 매개변수를 명시하지 않아야 함
    - 대신 기존의 제네릭 타입에 정의되어 있는 Element라는 타입을 사용할 수 있음

## 타입 제약
- 클래스 타입 또는 프로토콜로만 줄 수 있음
    - 즉, 열거형, 구조체 등의 타입은 타입 제약의 타입으로 사용할 수 없음
    - e.g. 우리가 자주 사용하는 제네릭 타입인 Dictionary의 키는 Hashable 프로토콜을 준수하는 타입만 사용 가능

## 프로토콜의 연관 타입
- 프로토콜에서 사용할 수 있는 플레이스홀더의 이름
    - 제네릭에서는 어떤 타입이 들어올지 모를 때 타입 매개변수를 통해 '종류는 알 수 없지만, 어떤 타입이 여기에 쓰일 것이다'라고 표현
    - 연관 타입은 타입 매개변수의 그 역할을 프로토콜에서 수행할 수 있도록 만들어진 기능

## 제네릭 서브스크립트
- 서브스크립트도 함수처럼 제네릭을 활용하여 타입에 큰 제한 없이 유연하게 구현할 수 있음
- 타입 제약을 사용하여 제네릭을 활용하는 타입에 제약을 줄 수도 있음

## 매개변수 다발
- 제네릭 타입과 제네릭 함수에서 다양한 타입의 매개변수들을 유연하게 전달할 수 있으며 매개변수의 개수도 자유롭게 조정할 수 있음
