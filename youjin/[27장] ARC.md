## ARC(Automatic Reference Counting)
- Swift가 프로그램의 메모리 사용을 관리하기 위하여 메모리 관리 기법인 ARC를 사용
- 더 이상 필요하지 않은 클래스의 인스턴스를 메모리에서 해제하는 방식으로 동작


## ARC와 가비지 컬렉션의 차이
- ARC와 가비지 컬렉션의 가장 큰 차이는 **참조를 계산**하는 시점
- ARC는 인스턴스가 언제 메모리에서 해제되어야 할지를 컴파일과 동시에 결정함
- 가비지 컬렉션은 프로그램 실행 중에 결정

## 메모리 관리 기법 비교
| 메모리 관리 기법 | ARC | 가비지 컬렉션 |
|----------------|-----|-------------|
| 참조 카운팅 시점 | 컴파일 시 | 프로그램 동작 중 |
| 장점 | 컴파일 당시 이미 인스턴스의 해제 시점이 정해져 있어서 인스턴스가 언제 메모리에서 해제될지 예측하기 쉬움. 특별한 규칙이 없기 때문에 인스턴스가 정해진 안전 메모리에서 해제됨 | 프로그램 동작 외에 메모리 감시를 위한 추가 자원이 필요하므로 한정적인 자원 환경에서는 성능 저하가 발생할 수 있음 |
| 단점 | ARC의 작동 규칙을 모르고 사용하면 인스턴스가 메모리에서 영원히 해제되지 않을 가능성이 있음 | 명확한 규칙이 없기 때문에 인스턴스가 정해진 안전 메모리에서 해제되지 예측하기 어려움 |

## 강한 참조 (Strong Reference)
- 인스턴스가 계속해서 메모리에 남아있어야 하는 명분을 만들어 주는 것
- 인스턴스는 참조 횟수가 0이 되는 순간 메모리에서 해제되는데, 인스턴스를 다른 인스턴스의 프로퍼티나 변수, 상수 등에 할당할 때 강한 참조를 사용하면 참조 횟수가 1 증가함

## 강한 참조의 특징
- 클래스 타입의 프로퍼티, 변수, 상수 등을 선언할 때 별도의 식별자를 명시하지 않으면 강한 참조를 수행
- 이제까지 우리는 일지 못하고 써왔지만 프로퍼티와 변수, 상수를 모두 강한 참조로 선언해왔던 것

## 강한 참조 순환
- 인스턴스끼리 서로가 서로를 강한 참조하는 것
- 강한 참조 순환이 발생하면 자신을 강한 참조 프로퍼티로 갖는 인스턴스가 메모리에서 해제될 수 없음

## 약한 참조 (Weak Reference)
- 강한 참조와 달리 자신이 참조하는 인스턴스의 참조 횟수를 증가시키지 않음
- 참조 타입의 프로퍼티나 변수의 선언 앞에 weak 키워드를 써주면 그 프로퍼티나 변수는 자신이 참조하는 인스턴스를 약한 참조함
- 약한참조를 사용하면 자신이 참조하는 인스턴스가 메모리에서 해제될 수도 있음
    - 자신이 참조 횟수를 증가시키지 않기 때문에 그 인스턴스를 강한 참조하던 프로퍼티나 변수에서 참조 횟수를 감소시켜 0으로 만들면 자신이 참조하던 인스턴스가 메모리에서 해제되기 때문

## 약한 참조와 상수, 옵셔널
- 약한참조는 상수에서 쓸 수 있으나 만약 자신이 참조하던 인스턴스가 메모리에서 해제된다면 nil이 할당될 수 있어야 하기 때문에 약한참조를 할 때는 자신의 값을 변경할 수 있는 변수로 선언해야 함
- nil이 할당될 수 있어야 하므로 약한참조는 항상 옵셔널이어야 함
    - 즉, 옵셔널 변수만 약한 참조를 할 수 있음

## 미소유 참조(Unowned Reference)
- 인스턴스의 참조 횟수를 증가시키지 않는 참조

## 미소유 참조와 약한 참조의 차이
- 미소유 참조는 약한 참조와 달리 자신이 참조하는 인스턴스가 항상 메모리에 존재할 것이라는 전제를 기반으로 동작함
- 즉, 자신이 참조하는 인스턴스가 메모리에서 해제되더라도 스스로 nil을 할당해주지 않는다는 뜻
- 그렇기 때문에 미소유 참조를 하는 변수나 프로퍼티는 옵셔널이나 변수가 아니어도 됨

## 미소유 옵셔널 참조
- 클래스를 참조하는 옵셔널을 미소유로 표시할 수 있음
- ARC 소유 모델에 따르면 미소유 옵셔널 참조와 약한 참조를 같은 상황에 사용할 수 있음
- 차이가 있다면 미소유 옵셔널 참조는 항상 유효한 객체를 가리키거나 그렇지 않으면 nil을 할당해 주도록 직접 신경을 써야 함

## 클로저의 강한 참조 순환 문제
- 강한 참조 순환 문제는 두 인스턴스끼리의 참조일 때만 발생하는 것 외에 클로저가 인스턴스의 프로퍼티일 때, 클로저의 값 획득 특성 때문에 발생
- 예를 들어 클로저 내부에서 `self.someProperty`처럼 인스턴스의 프로퍼티에 접근할 때, 클로저 내부에서 `self.someMethod()`처럼 인스턴스의 메서드를 호출할 때 값 획득이 발생할 수 있는데, 두 경우 모두 클로저가 `self`를 획득하므로 강한참조 순환이 발생

## 클로저의 강한 참조 순환 해결
- 강한 참조 순환이 발생하는 이유는 클로저가 클래스와 같은 참조 타입이기 때문
- 클로저를 클래스 인스턴스의 프로퍼티로 할당하면 클로저의 참조가 할당
- 이때 참조 타입과 참조 타입이 서로 강한 참조를 하기 때문에 강한 참조 순환 문제가 발생

## 획득 목록 (Capture List)
- 클로저 내부에서 참조 타입을 획득하는 규칙을 제시해줄 수 있는 기능
- 클로저 내부의 매개변수 목록 이전 위치에 작성
- 참조 방식과 참조할 대상을 대괄호([])로 둘러싼 목록 형식으로 작성하며 획득 목록 뒤에는 in 키워드를 작성
