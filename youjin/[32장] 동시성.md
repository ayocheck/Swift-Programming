## 동시성 개요
- 비동기, 병렬 코드를 혼합해 사용하는 것
- Swift 5.5에서 동시성(Concurrency) 기능을 자체 기능으로 내장
- GCD는 계속 활용 가능하나 언어 외부에 의존하게 되므로 한계
- GCD는 스레드를 기반으로 동작, 이전의 동작이 일시 중지된 스레드에서 재개
- 스위프트의 동시성 환경에서는 작업이 재개될 때 어떤 스레드에서 동작할 지 알 수 없음
    - 중단 시점의 스레드와 복귀 시점의 스레드가 일치하지 않을 수 있음 (메인 액터 제외)

## 작업
- 동시성 프로그래밍에서 비동기적으로 실행할 수 있는 작업의 최소 단위는 `Task`
- 실행할 코드의 블록, 즉 클로저를 통해 생성할 수 있으며 생성 직후에 즉시 실행
- `Task` 클로저 내부에 동시성 코드를 작성하고 호출하면 동시성 프로그래밍 문맥이 아닌 곳에서 동시성 프로그래밍 기능을 활용할 수 있음

## 비동기 함수의 정의와 호출
- `async` 함수는 실행 도중 일시 중단(Suspended)되었다가 다른 작업을 마치고 다시 복귀하여 이어서 실행될 수 있음
- 즉, 함수 실행 도중 다른 작업을 위해 멈추었다가 다시 이어서 실행될 가능성 O
- `await`를 분리 호출하면 그 호출이 끝날 때까지 작업이 일시 중단된다
    - 중단되는 지점은 `await` 키워드가 명시된 호출 부분

## 구조적 동시성 (Structured Concurrency)
- 작업이 부모와 자식 관계를 가지고 작업 그룹으로도 묶일 수 있는 것
    - 부모 작업은 자식 작업이 끝날 때까지 기다려야 함
    - 자식 작업의 우선순위를 높이면 부모 작업의 우선순위도 자동으로 상승
    - 부모 작업을 취소하면 자식 작업도 자동으로 취소
    - 작업의 로컬 값이 자식 작업으로 효율적이고 자동으로 전파
    
## 작업 그룹
- 비동기 코드는 암묵적으로 작업을 생성하여 실행함
- 작업 그룹을 사용하면 작업의 우선순위나 취소 등을 더 세밀하게 제어할 수 있음
- `withThrowingTaskGroup(of:)` 함수를 이용해 작업 그룹을 만들고 실행할 수 있음
    - 오류가 없는 함수라면 `withTaskGroup(of:)`도 사용 가능

## 작업의 취소
- 작업 그룹 전체를 취소하려면 `cancelAll()` 이용
- 작업에 취소 명령을 내려도 작업은 끝까지 진행되기 때문에 긴 작업은 수동으로 종료해주는 것이 좋음
- `checkCancellation()` 메서드, `isCancelled` 프로퍼티로 작업이 취소되었는지 확인 가능

## 비구조적 동시성 (Unstructured Concurrency)
- 위계적 관계를 벗어나 부모를 갖지 않는 새로운 독립적 작업을 생성할 수 있는 것

## 비구조적 작업을 만드는 방법
- `Task.init(priority:operation:)` 이니셜라이저
    - 문맥에서 새로운 작업을 생성할 때 사용
- `Task.detached(priority:operation:)` 메서드
    - 현재 액터 문맥에서 맺어난 분리된 작업을 생성할 때 사요
- 두 방법 모두 새로운 작업 인스턴스를 반환

## 액터
- 클래스와 같은 참조 타입이지만 상속은 불가능
- 작업 간에 정보를 공유해야 할 때 동시에 실행되는 작업 코드 사이에 안전하게 정보를 공유할 수 있음
- 상태 값을 안전하게 관리, 보호해 동시성 문제를 해결하는 데 중점을 둠
- 액터의 메서드, 프로퍼티를 활용할 때에는 무조건 `await`을 사용
    - 근본적으로 일이 끝날 때까지 기다려야 하는 구조
    - 데이터 경쟁(Data Race)을 방지하는 데 매우 유용함
    - 단, 액터 내부에서는 `await` 없이 서로 호출 가능
        - 외부에서 호출할 때 `await`을 사용하기 때문
- 여러 비동기 작업이 동시에 접근하는 데이터를 안전하게 보호하고 상태 값 변경을 직렬화해 데이터의 일관성을 유지하는 데 도움을 줌

## 전송 가능한 타입 (Sendable Types)
- 동시 실행 도메인 사이에서 안전하게 전달할 수 있는 타입을 의미
- 클래스와 같이 보호하지 않는 가변 상태는 동시 실행 도메인(Concurrency Domain) 사이에 공유할 때 문제가 발생할 수 있음
- 값 타입은 기본적으로 동시 실행 도메인 사이에서 안전하게 공유 가능한 `Sendable` 타입
    - 스위프트의 간단한 값 타입은 대부분 `Sendable` 프로토콜을 준수
- 암시적으로 전송 가능한 타입을 전송 불가능한 타입으로 변경하려면 `@available` 속성을 활용해 명시적 비활성화 가능

## 전송 가능한 타입 조건
- 가변 상태 값의 타입이 `Sendable` 프로토콜을 준수하는 경우
- 읽기 전용 프로퍼티만 가진 구조체나 클래스인 경우 (가변 상태가 없는 경우)
- `@MainActor`로 표기된 클래스 또는 특정 프로퍼티에 대한 접근을 직렬화하는 클래스인 경우 (가변 상태의 안전성을 보장하는 보호 매커니즘이 있는 경우)

## 미복사 타입 (Noncopyable Type, ~Copyable)
- 스위프트 동시성 기능에 직접적으로 포함되는 기능은 아님
- 스위프트의 메모리 관리와 동시성 안전성을 강화하기 위해 도입
- `Copyable` 타입
    - 복사가 가능한 타입
    - 구조체나 열거형과 같은 값 타입
    - 복사 시 값 자체가 복사되며 원본과 복사본은 서로 독립적인 상태
- `~Copyable`
    - 복사가 불가능한 상태
    - 유일한 자원을 관리할 때 유용
    - 구조체나 열거형 등에 사용 가능, 스위프트 6부터는 제네릭 타입에도 사용할 수 있음
        - `~Copyable` 타입의 구조체, 열거형은 `deinit` 구현 가능
